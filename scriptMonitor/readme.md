(Ме тут написали, что слетает кодировка файлов и пишет все в крякозяблях. Файлы должны быть в кодировке Win1251. 
Вот https://yadi.sk/d/cbbPNcN0Z5GMbw  на всякий случай).

Монитор рынка. 

Скрипт для Квика, выполняющий подключенные модули для указанного списка бумаг.

Теперь поясню зачем вообще эта модульность. Сам скрипт - это просто визуальная составляющая алгоритмов. Мне нужен был инструмент, позволяющий запускать мои модули для списка бумаг для разных интервалов. Я использую алгоритмы анализа объемов, поиска формаций движения, регресии, прорыв ценового канала. Открывать график каждой бумаги, смотреть - это большое время. Поэтому и написал этот инструмент. В свободной поставке я реализовал модули: расчет EMA, RSI, VSA, NRTR, регрессии, объемов.
Добавил модуль расчета торгового диапазона и сигнала выхода из него.

Есть таблица со списком инструментов, выводимые значения алгоритмов, интрументы для выставления заявок.

![](./pict/pict1.PNG)

Что у нас здесь. 

Бумаги из файла настроек. Далее последняя цена, % изменения с открытия, % изменения за неделю (на самом деле -5 дней), цена открытия, дельта от открытия, дневной ATR, размер и средняя позиции (то, что куплено). Дневной ATR считается за период указанный в файле со списком бумаг. Я сделал подсветку значения ATR, если в течении дня было превышение значения. Т.к. не всегда смотришь за торгами, то открыв монитор, можно увидеть было ли сильное движение по бумаге в течении дня.

Это первый блок, фиксированных колонок. Далее начинаются колонки, которые показывают рассчитанные значения индикаторов(алгоритмов).

В коде скрипта можно найти строки:

    dofile (getScriptPath().."\\monitorStepNRTR.lua") --stepNRTR алгоритм. Инициализация - initstepNRTR, расчет - stepNRTR
    dofile (getScriptPath().."\\monitorEMA.lua") --EMA алгоритм. Инициализация - initEMA, расчет - EMA, allEMA
    dofile (getScriptPath().."\\monitorRSI.lua") --EMA алгоритм. Инициализация - initRSI, расчет - RSI
    dofile (getScriptPath().."\\monitorReg.lua") --Регрессия алгоритм. Инициализация - initReg, расчет - Reg
    dofile (getScriptPath().."\\monitorVolume.lua") --RT алгоритм контроль повышенного объема. Инициализация - initVolume, расчет - Volume
    dofile (getScriptPath().."\\monitorVSA.lua") --VSA алгоритм. Инициализация - initVSA, расчет - VSA
    dofile (getScriptPath().."\\monitorRange.lua") --range


Это подключаемые модули расчета.

Колонки выводимые в таблицу определяются такой структурой:
Оновлено: перенес в файл scriptMonitorPar.

    INTERVALS = {
        ["names"] =             {"H1VSA",      "H1",         "H4",            "D",            "W",            "dEMA64",       "dEMA182",      "D Reg",        "D RSI 29"},
        ["visible"] =           {false,         true,          true,           true,           true,           true,           true,           true,           true}, --признак видимости, если невидима, то просто идет расчет и вывод сигналов
        ["width"] =             {0,             12,            12,             12,             12,             12,             12,             12,             12}, --ширина колонки
        ["values"] =            {INTERVAL_H1,   INTERVAL_H1,   INTERVAL_H4,    INTERVAL_D1,    INTERVAL_W1,    INTERVAL_D1,    INTERVAL_D1,    INTERVAL_D1,    INTERVAL_D1},
        ["initAlgorithms"] =    {initVSA,       initstepNRTR,  initstepNRTR,   initstepNRTR,   initstepNRTR,   initEMA,        noSignal,       initReg,        initRSI},   --функции инициализации алгоритма
        ["algorithms"] =        {VSA,           stepNRTR,      stepNRTR,       stepNRTR,       stepNRTR,       allEMA,         noSignal,       Reg,            RSI},       --функции алгоритма, определены в подключаемых файлах
        ["signalAlgorithms"] =  {signalVSA,     up_downTest,   up_downTest,    up_downTest,    up_downTest,    signalAllEMA,   noSignal,       signalReg,      signalRSI}, --функции алгоритма, определены в подключаемых файлах
        ["settings"] =          {VSASettings,   NRTRSettings,  NRTRSettings,   NRTRSettings,   NRTRSettings,   allEMASettings, {},             RegSettings,    RSISettings}, --настройки алгоритмов, параметры функции алгоритма
        ["recalculatePeriod"] = {0,             0,             0,              60,             60,             60,             60,             60,             0}   --настройки пересчета алгоритмов в минутах. для интервалов день и более - можно пересчитать данные, чтобы выводит сигналф внутри дня. 0 - не считать
    }


    --[[INTERVALS = {
        ["names"] =             {"H1VSA",         "M15",          "D",            "W",            "dEMA182",      "dReg",        "Trend",        "dRSI29"},
        ["visible"] =           {false,           true,           true,           true,           true,           true,          true,           true}, --признак видимости, если невидима, то просто идет расчет и вывод сигналов
        ["width"] =             {0,               12,             12,             12,             12,             12,            12,             12}, --ширина колонки
        ["values"] =            {INTERVAL_H1,     INTERVAL_M15,   INTERVAL_D1,    INTERVAL_W1,    INTERVAL_D1,    INTERVAL_D1,   INTERVAL_D1,    INTERVAL_D1},
        ["initAlgorithms"] =    {initVSA,         initRangeBar,   initstepNRTR,   initstepNRTR,   initEMA,        initReg,       nil,            initRSI},   --функции инициализации алгоритма
        ["algorithms"] =        {VSA,             rangeBar,       stepNRTR,       stepNRTR,       EMA,            Reg,           nil,            RSI},       --функции алгоритма, определены в подключаемых файлах
        ["signalAlgorithms"] =  {signalVSA,       rangeTest,      NRTRTest,       NRTRTest,       up_downTest,    signalReg,     nil,            signalRSI},  --функции алгоритма, определены в подключаемых файлах
        ["settings"] =          {VSASettings,     rangeSettings,  NRTRSettings,   NRTRSettings,   EMA182Settings, RegSettings,   {},             RSISettings},   --настройки алгоритмов, параметры функции алгоритма
        ["recalculatePeriod"] = {0,               60,             60,             60,             60,             60,            0,              0}   --настройки пересчета алгоритмов в минутах. для интервалов день и более - можно пересчитать данные, чтобы выводит сигналф внутри дня. 0 - не считать
    }


    INTERVALS = {
        ["names"] =             {"H1VSA",         "H4",           "D",            "dReg",        "Trend",      "dRSI29"     },
        ["visible"] =           {false,           true,           true,           true,          true,         true         }, --признак видимости, если невидима, то просто идет расчет и вывод сигналов
        ["width"] =             {0,               12,             12,             12,            12,           12           }, --ширина колонки
        ["values"] =            {INTERVAL_H1,     INTERVAL_H4,    INTERVAL_D1,    INTERVAL_D1,   INTERVAL_D1,  INTERVAL_D1  },
        ["initAlgorithms"] =    {initVSA,         initRangeBar,   initRangeBar,   initReg,       nil,          initRSI      },   --функции инициализации алгоритма
        ["algorithms"] =        {VSA,             rangeBar,       rangeBar,       Reg,           nil,          RSI          },   --функции алгоритма, определены в подключаемых файлах
        ["signalAlgorithms"] =  {signalVSA,       rangeTest,      rangeTest,      signalReg,     nil,          signalRSI    },   --функции алгоритма, определены в подключаемых файлах
        ["settings"] =          {VSASettings,     rangeSettings,  rangeSettings,  RegSettings,   {},           RSISettings  },   --настройки алгоритмов, параметры функции алгоритма
        ["recalculatePeriod"] = {0,               60,             60,             60,            0,            0            }    --настройки пересчета алгоритмов в минутах. Lля интервалов день и более можно пересчитать данные, чтобы выводит сигнал внутри дня. 0 - не считать
    }
    ]]--


Здесь есть разные варианты настроек. Два примера закомментированы.

У нас здесь имя колонки, признак видимости, ширина, значение интервала расчета, алгоритмы, настройки, переиод пересчета.

Имя, ширина, интервал понятно для чего. Зачем признак видимости? Для примера я сделал алгоритм VSA на часовом интервале. Выводить в интерфейс что-то не требуется, а вот рассчитать сигналы повышенного объема надо. Делаем невидимую колонку, алгоритм будет вызываться на каждой свечке и производить расчет, выдавать сигнал.

Алгоритмы - это просто имена процедур из подключенных модулей. Три типа процедур - инициализация (очистка памяти для новой бумаги), расчет показателей, вывод сигнала.
В каждом модуле я сделал такие процедуры. По образу можно писать свои. Также я встроил в основной модуль процедуру вывода сигнала up_downTest. Она выводит значения в колонку таблицы, окрашивает в нужный цвет, выдает сигнал при превышении (снижении) значения на прошлой закрытой свечке. Ее можно использовать когда не требуется что-то специфическое.

settings - это структура настроек в файле алгоритма, выполненная по образу обычных индикаторов. Вообще алгоритмы расчета очень близки к процедурам типовых индикаторов Квика. В каждом файле модуля есть свои settings. А в таблице INTERVALS файла scriptMonitorPar указаны настройки алгоритма колонки.

    RSISettings = {
        period    = 29,
        Size = 1000
    }

Еще немного про расчет значений на одном интервале. Допустим, мне надо на дневном интервале рассчитать две скользящие. Зачем вызывать два раза расчет? Проще вызвать один раз с указанным списком интервалов. Я сделал для примера такой вариант:

    "dEMA64",       "dEMA182",   
    true,           true,       
    12,             12,         
    INTERVAL_D1,    INTERVAL_D1,
    initEMA,        noSignal,   
    allEMA,         noSignal,   
    signalAllEMA,   noSignal,   
    allEMASettings, {},         
    60,             60,         

Здесь указаны две колонки. В первой идет вызов процедур расчета allEMA, процедуры сигнала signalAllEMA и настройки allEMASettings

    allEMASettings = {
        periods = {64,182},
        Size = 1000,
        testZone = 10
    }

Во второй колонке вместо вызова процедуры расчета идет вызов пустой процедуры noSignal, пустые настройки, т.к. в ней уже считать ничего не надо. Мы все посчитали в первой колонке, выведя значения и сигналы сразу для двух колонок. Т.о. мы сокращаем время выполнения и нагрузку. Как побочный эффект, т.к. у нас есть рассчитанные значения сразу для двух скользящих, то мы можем вывести сигнал о их пересечении. Это я сделал для примера в процедуре signalAllEMA модуля monitorEMA.

Последняя строка recalculatePeriod нужна для указания периода перерасчета алгоритма. Зачем она нужна, если на каждой новой свечке итак будет расчет? Я сделал такую настройку для больших интервалов. Допустим, есть дневной (или даже недельный) интервал. Его расчет будет произведен один раз при старте скрипта, т.к. боьше новых свечек не будет. Но есть сигналы, которые хотелось мониторить внутри дня. Поясню на примере регресии. Есть линия регресии, есть отклонения +- сигма, формирующие канал. Цена может приблизиться к границе канала и отскочить. Вот эти моменты и хотелось бы мониторить. Иначе сигнал поступит только завтра. А сигнал резкого касания границы и отскока вообще можно не получить. Поэтому я сделал возможность пересчета алгоритма каждый указанный интервал (в минутах), чтобы получать сигналы.

Далее, ниже таблицы интервалов, есть таблица:

    realtimeAlgorithms = {
        ["initAlgorithms"] =    {initVolume},   --функции инициализации алгоритма
        ["functions"] =         {Volume},
        ["recalculatePeriod"] = {60}            --секунд
    }

Это определение алгоритмов реального времени. Зачем они? Допустим, я хочу каждые 30 секунд вызвать некий алгоритм, что-то посчитать, вывести сообщение. Дял примера, я сделал модуль monitorVolume, в котором рассчитывается средний объем за указанное количество секунд, вывод сообщения о повышенном объеме. Но можно ведь написать и алгоритм чтения Twitter ленты с фильтром по бумагам.

В поставке я наполнил таблицу всеми вариантами, чтобы можно было оценить (понять) работу алгоритмов.

Теперь немного про вывод сигналов. В файле настроек для каждой бумаги можно указать надо ли выводить сигнал, проигрывать ли мелодию. Если все это указано, то, помимо вывода самого значения в таблицу, будет выведено сообщение и проиграна мелодия. Как я уже писал выше, типовой сигнал - это цена превысила (опустилась ниже) значение. Но я еще реализовал сигналы прохода, отскока от зоны. В settings колонки есть значение testZone. Оно измереяется в минимальных шагах цены инструмента. Зона определяется как значение алгоритма +- testZone*шаг цены. Если цена зашла внутрь зоны (сверху или снизу), то выдается сигнал. Если отскочила, тоже. Я не использую скользящие средние, но очень (очень) многие да. Как раз для случаев отскока от скользящей я и сделал такого рода сигналы для примера. Еще это используется в RSI. Но там сигналов больше. Есть значения 30, 50, 70. Вот как раз подход и отскок от этих значений и мониторится в поставляемом модуле.

Далее, для лучшего визуального контроля я сделал градацию цвета. Для примера, значение RSI = 50 считаем нейтральным - цвет белый. Близкий к 100 насыщенный зеленый, к 0 - красный. А для промежуточных значений цвет меняет насыщенность. Этот же подход я сделал в модуле регресии при подходе к границам сигма каналов.

Теперь немного как это можно использовать. Есть такая стратегия - строим скользящие средние начиная с интервала 1 минута до недели. Параметры для каждого интервала либо одинаковые, либо разные. Далее смотрим на поведение цены. Если, начиная с младших интервалов начинают пследовательно поступать сигналы о пересечении скользящей, то это может быть признаком разворота. Так вот, если есть возможность просто глазами увидеть цветовую последовательность сигналов, то можно увидеть начало движения. Для этого мы делаем  необходимое количество колонок в таблице, указывая нужные параметры. Это один из примеров.

Обновлено.

Для некоторых модулей есть свои файлы параметров. Зачем они нужны. В таблице settings модуля алгоритма указаны значения по-умолчанию для всех бумаг и интервалов. Но для каждой бумаги и интервала лучше использовать свои параметры. Скажем, на 15 минутах свои параметры, а на дневках свои. Также и для разных бумаг.
Поэтому, для примера, в алгоритме rangeMonitor есть файл csv с настройками, для некоторых бумаг и интервалов. Можно добавлять, удалять, менять своими значениями.

    SecCode;ChartId;Interval;isLong;isShort;bars;ratioFactor;kstd;ATR_factor
    FEES;testGraphFEES;1440;1;1;27;0.7;1.8;3
    ALRS;testGraphALRS;1440;1;1;27;0.7;1.8;3
    MOEX;testGraphMOEX;1440;1;1;27;0.7;1.8;3
    SBER;testGraphSBER;1440;1;1;27;0.7;1.8;3
    GMKN;testGraphGMKN;1440;1;1;27;0.7;1.8;3


Далее идут колонки для торговли.

Цена - цена выставления заявки, 0 - по рынку. Далее размер позиции и кнопки управления ей. Далее команды на покупку и продажу. Последняя команда - закрыть все. Она появляется, если у Вас позиция <> 0. Она совершается по рынку.

Для предотвращения случайностей все команды совершаются двойным кликом мышки. Чтобы очистить цену высталения позиции достаточно нажать в выбранной строке Backspace. Если надо ввести конкретную цену, то можно выбрать цену открытия или текущую, кликнув (дважды) по соотвествующей колонке. Также можно дважды кликнуть по колонке значения алгоритма. Допустим, у Вас там расчет скользящей. Т.о. можно быстро ввести заявку по цене значения скользящей соответствующего интервала.

Если надо ввести конкретное значение цены, то надо дважды кликнуть по цене заявки, появится окно ввода. В нем надо выбрать строку и ввести цифры. Очистка тоже Backspace.
Тоже самое для размера позиции. Дважды кликнуть по полю и ввести или воспользоваться кнопками +-.

![](./pict/pict2.PNG)

Горячие клавиши:
Для быстрого снятия всех заявок по иструменту, встаем на строку, нажимаем Shift+D, стоп-заявок - Shift+S.
Shift+A - для включения/выключения звукового сопровождения сигналов по инструменту. У меня звук выключен по умолчанию для всех бумаг. Но можно прямо из монитора, не меняя файл параметров, включить звук в дни, когда надо отслеживать какой-то инструмент.

Добавлено.

Если запустить скрипт логирующий сделки, то прямо из монитора можно будет открывать таблицу совершенных сделок.
Скрипт называется deals. Я его брал с quikluacsharp, немного переделав. Его надо запустить и не выключать, тогда он будет автозапускаться и всегда логировать сделки. 
В файле scriptMonitorPar указан путь папки с логом TradesFilePath = getWorkingFolder().."\\Deals\\".
По умолчанию - это папка Deals, созданная в каталоге установки Квика.
Чтобы открыть сделки по инструменту, надо дважды щелкнуть по имени в таблице монитора. При открытии таблицы, сделки будут распределены по ФИФО. Незакрытые будут выделены зеленым цветом.

Вот и все.

Теперь как все это заставить лететь:
Обновлено: теперь все можно положить в одну папку, скажем ScriptMonitor, расположенную где угодно (ранее надо было создавать дополнительные папки).

Скрипт и модули кладем собираем в онду папку, кладем куда угодно.

В файле scriptMonitor.csv находится список бумаг для монитора, с указанием дополнительных настроек.

    Код класса;Имя;Идентификатор;Выводить сообщения;Проигрывать звук;Рабочий объем;ATR период
    TQBR;Сбербанк;SBER;1;0;1;29
    TQBR;ВТБ;VTBR;1;0;1;29
    TQBR;Мосбиржа;MOEX;1;0;1;29
    TQBR;Система;AFKS;1;0;1;29


Чтобы проигрывался звук, надо положить библиотеку w32.dll в корневую папку Квика, либо отключайте в скрипте и в настройках в файле scriptMonitorPar.

    local w32 = require("w32")

Далее, для торговли надо в фале scriptMonitorPar указать ваши данные от брокера - счет, код клиента.

    ACCOUNT     = 'L01-00000F00'        -- Идентификатор счета
    CLIENT_CODE = 'DFFGJ43'

Если Вы хотите сменить настройки хранения лога и файла параметров то здесь это можно сделать в файле scriptMonitorPar:

FILE_LOG_NAME = getScriptPath().."\\scriptMonitorLog.txt" -- ИМЯ ЛОГ-ФАЙЛА
PARAMS_FILE_NAME = getScriptPath().."\\scriptMonitor.csv" -- ИМЯ ЛОГ-ФАЙЛА

Теперь особенности. Т.к. скрипт тянет данные напрямую от брокера, то в Квике должен быть разрешен вывод данных по списку бумаг. Далее, для быстроты получения данных, лучше, чтобы был открыт график инструмента.

У меня открыты графики для списка бумаг. Если графика нет, то Квик данные не получает с сервера - оптимизация трафика. В этом случае скрипт посылает заявку на сервер для потока данных и по их приходу начнет их анализировать.

Сразу поясню - я не использую все эти модули. Я написал модули скользящих средних, RSI и другие для примера, чтобы Вы могли понять как писать свои или использовать их. Кто-то ведь торгует по скользящим и довольно успешно. Когда Вы откроете скрипт на Вас посыпятся сигналы. Их много, т.к. я все включил сразу. Отключайте ненужное, перенастраивайте.

Для меня же - это просто монитор показателей и платформа для алготорговли. Ведь вместе с сигналом можно и сделку совершить. В скрипт добавлены процедуры для торговли - ничто не мешает написать робота. 
